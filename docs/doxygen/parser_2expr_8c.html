<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lux: src/parser/expr.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lux<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A low-level compiled alternative to C, C++, and more!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="dir_6cd8491d143eb218b70983dbdb3c58bc.html">parser</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">expr.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Expression parsing implementation for the programming language compiler.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="parser_8h_source.html">parser.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for expr.c:</div>
<div class="dyncontent">
<div class="center"><img src="parser_2expr_8c__incl.png" border="0" usemap="#asrc_2parser_2expr_8c" loading="lazy" alt=""/></div>
<map name="asrc_2parser_2expr_8c" id="asrc_2parser_2expr_8c">
<area shape="rect" title="Expression parsing implementation for the programming language compiler." alt="" coords="105,5,225,30"/>
<area shape="rect" title=" " alt="" coords="5,78,66,103"/>
<area shape="poly" title=" " alt="" coords="145,33,71,73,68,68,142,28"/>
<area shape="rect" title=" " alt="" coords="89,78,152,103"/>
<area shape="poly" title=" " alt="" coords="160,32,138,66,134,63,155,29"/>
<area shape="rect" title=" " alt="" coords="177,78,241,103"/>
<area shape="poly" title=" " alt="" coords="174,29,196,63,191,66,170,32"/>
<area shape="rect" href="parser_8h.html" title="Recursive descent and Pratt parser for the Zura language." alt="" coords="265,78,334,103"/>
<area shape="poly" title=" " alt="" coords="188,28,265,68,263,73,186,33"/>
<area shape="rect" title=" " alt="" coords="167,296,234,321"/>
<area shape="poly" title=" " alt="" coords="268,106,235,124,220,137,208,152,196,184,192,219,193,252,197,280,192,281,188,252,187,218,191,183,204,149,216,133,232,120,265,101"/>
<area shape="rect" href="ast_8h.html" title=" " alt="" coords="218,151,301,175"/>
<area shape="poly" title=" " alt="" coords="295,105,276,138,271,136,291,102"/>
<area shape="rect" href="memory_8h.html" title="Arena allocator and growable array utilities for fast memory management." alt="" coords="297,223,478,248"/>
<area shape="poly" title=" " alt="" coords="309,101,375,208,370,211,304,104"/>
<area shape="rect" href="lexer_8h.html" title="Tokenizer (lexer) definitions and API for lexical analysis of source code." alt="" coords="375,151,477,175"/>
<area shape="poly" title=" " alt="" coords="322,101,393,140,391,145,319,106"/>
<area shape="poly" title=" " alt="" coords="257,177,214,283,209,281,252,175"/>
<area shape="rect" title=" " alt="" coords="258,296,333,321"/>
<area shape="poly" title=" " alt="" coords="265,175,291,280,286,281,260,176"/>
<area shape="poly" title=" " alt="" coords="282,174,354,213,352,218,279,178"/>
<area shape="poly" title=" " alt="" coords="358,251,247,293,245,288,356,246"/>
<area shape="poly" title=" " alt="" coords="374,251,324,289,321,284,371,246"/>
<area shape="rect" title=" " alt="" coords="357,296,434,321"/>
<area shape="poly" title=" " alt="" coords="391,248,395,280,390,281,386,249"/>
<area shape="poly" title=" " alt="" coords="422,177,403,211,399,208,417,175"/>
<area shape="rect" title=" " alt="" coords="502,223,566,248"/>
<area shape="poly" title=" " alt="" coords="445,174,505,212,502,217,443,178"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a481c538e520948ab138a8c5b0a8324c6" id="r_a481c538e520948ab138a8c5b0a8324c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a481c538e520948ab138a8c5b0a8324c6">primary</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a481c538e520948ab138a8c5b0a8324c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses primary expressions (literals and identifiers)  <br /></td></tr>
<tr class="memitem:a517fa2b63adec675d032991a3a712572" id="r_a517fa2b63adec675d032991a3a712572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a517fa2b63adec675d032991a3a712572">unary</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a517fa2b63adec675d032991a3a712572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses unary expressions (prefix operators)  <br /></td></tr>
<tr class="memitem:a1ecf965f76c333d977e1ffafbef4174e" id="r_a1ecf965f76c333d977e1ffafbef4174e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ecf965f76c333d977e1ffafbef4174e">grouping</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a1ecf965f76c333d977e1ffafbef4174e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses grouped expressions (parenthesized expressions)  <br /></td></tr>
<tr class="memitem:aae76f2e2da0e519b78628915240200dd" id="r_aae76f2e2da0e519b78628915240200dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae76f2e2da0e519b78628915240200dd">binary</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:aae76f2e2da0e519b78628915240200dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses binary expressions (infix operators)  <br /></td></tr>
<tr class="memitem:a77a8786dfb25898d7c4ffbc0ca8eafcf" id="r_a77a8786dfb25898d7c4ffbc0ca8eafcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a8786dfb25898d7c4ffbc0ca8eafcf">call_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:a77a8786dfb25898d7c4ffbc0ca8eafcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses function call expressions.  <br /></td></tr>
<tr class="memitem:a683f4d2d2d297649d7b0d2d3dc3bad8e" id="r_a683f4d2d2d297649d7b0d2d3dc3bad8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a683f4d2d2d297649d7b0d2d3dc3bad8e">assign_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:a683f4d2d2d297649d7b0d2d3dc3bad8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses assignment expressions.  <br /></td></tr>
<tr class="memitem:a6ec4a015146e7598655f260ecb559a84" id="r_a6ec4a015146e7598655f260ecb559a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ec4a015146e7598655f260ecb559a84">prefix_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:a6ec4a015146e7598655f260ecb559a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses prefix expressions (member access, indexing, postfix operators)  <br /></td></tr>
<tr class="memitem:ade768344c2d92f84219dfbddb9d37987" id="r_ade768344c2d92f84219dfbddb9d37987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade768344c2d92f84219dfbddb9d37987">array_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:ade768344c2d92f84219dfbddb9d37987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses array literal expressions.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Expression parsing implementation for the programming language compiler. </p>
<p>This file contains implementations for parsing all types of expressions in the programming language. It works in conjunction with the Pratt parser implementation in <a class="el" href="parser_8c.html" title="Implementation of the parser module for the programming language compiler.">parser.c</a> to handle operator precedence and associativity correctly.</p>
<p>The expression parser handles:</p><ul>
<li>Primary expressions: literals, identifiers</li>
<li>Unary expressions: prefix and postfix operators</li>
<li>Binary expressions: arithmetic, logical, comparison operators</li>
<li>Function call expressions with argument lists</li>
<li>Assignment expressions</li>
<li>Member access and array indexing expressions</li>
<li>Grouping expressions with parentheses</li>
<li>Array literal expressions</li>
</ul>
<p>All parsing functions follow the Pratt parser pattern, where expressions are built recursively based on operator precedence (binding power). The functions correspond to null denotation (nud) and left denotation (led) operations.</p>
<dl class="section author"><dt>Author</dt><dd>Connor Harris </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2025 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ade768344c2d92f84219dfbddb9d37987" name="ade768344c2d92f84219dfbddb9d37987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade768344c2d92f84219dfbddb9d37987">&#9670;&#160;</a></span>array_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * array_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses array literal expressions. </p>
<p>Parses an array literal expression.</p>
<p>This function handles array literal syntax with square brackets containing a comma-separated list of expressions: <span class="tt">[expr1, expr2, expr3, ...]</span>. Empty arrays are allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created array expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Array literals can contain any number of expressions (including zero) </dd>
<dd>
Elements are separated by commas with optional trailing comma support </dd>
<dd>
Each element can be any valid expression (literals, identifiers, function calls, etc.) </dd>
<dd>
Memory for the element array is managed using growable arrays </dd>
<dd>
Empty arrays are valid: <span class="tt">[]</span></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#a28bbedff4d2051636a3b72f4e893c0dd">create_array_expr()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="structGrowableArray.html" title="Growable array backed by an arena allocator.">GrowableArray</a> </dd></dl>

</div>
</div>
<a id="a683f4d2d2d297649d7b0d2d3dc3bad8e" name="a683f4d2d2d297649d7b0d2d3dc3bad8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683f4d2d2d297649d7b0d2d3dc3bad8e">&#9670;&#160;</a></span>assign_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * assign_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a></td>          <td class="paramname"><span class="paramname"><em>bp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses assignment expressions. </p>
<p>Parses an assignment expression.</p>
<p>This function handles assignment operations where a value is assigned to a variable or other assignable expression (lvalue). The left operand must be a valid assignment target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">left</td><td>The left-hand side expression being assigned to (already parsed) </td></tr>
    <tr><td class="paramname">bp</td><td>The current binding power context (unused in this function)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created assignment expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assignment is right-associative with low precedence </dd>
<dd>
The left operand should be an lvalue (identifier, member access, index) </dd>
<dd>
The right operand is parsed with BP_ASSIGN precedence for right-associativity </dd>
<dd>
Validation of assignment targets is typically done during semantic analysis</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#a00cc73883336df2dfb1e4e4b471d288f">create_assignment_expr()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="parser_8h.html#a9a2a8ba5bea0c6ee41058bf6f8eb6178" title="Report a parser error with detailed location info.">parser_error()</a> </dd></dl>

</div>
</div>
<a id="aae76f2e2da0e519b78628915240200dd" name="aae76f2e2da0e519b78628915240200dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae76f2e2da0e519b78628915240200dd">&#9670;&#160;</a></span>binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a></td>          <td class="paramname"><span class="paramname"><em>bp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses binary expressions (infix operators) </p>
<p>Parses a binary expression.</p>
<p>This function handles all binary infix operators including arithmetic (+, -, *, /), comparison (==, !=, &lt;, &gt;, &lt;=, &gt;=), logical (&amp;&amp;, ||), and bitwise (&amp;, |, ^) operators. It's called as part of the left denotation (led) process in the Pratt parser.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">left</td><td>The left operand expression (already parsed) </td></tr>
    <tr><td class="paramname">bp</td><td>The current binding power context for precedence handling</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created binary expression AST node</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is part of the Pratt parser's led (left denotation) mechanism </dd>
<dd>
The left operand is already parsed by the time this function is called </dd>
<dd>
The right operand is parsed with the current binding power to handle precedence </dd>
<dd>
Operator associativity is handled by the binding power passed to parse_expr </dd>
<dd>
Uses a lookup table to map token types to binary operator types</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#a7147d252c953b63df28b15dabc8ea285">create_binary_expr()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="ast_8h.html#a751965739ae765593a89b5fd608d480c">BinaryOp</a>, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a> </dd></dl>

</div>
</div>
<a id="a77a8786dfb25898d7c4ffbc0ca8eafcf" name="a77a8786dfb25898d7c4ffbc0ca8eafcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a8786dfb25898d7c4ffbc0ca8eafcf">&#9670;&#160;</a></span>call_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * call_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a></td>          <td class="paramname"><span class="paramname"><em>bp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses function call expressions. </p>
<p>Parses a function call expression.</p>
<p>This function handles function call syntax where the left operand is the function to call and the arguments are provided in parentheses. It supports zero or more arguments separated by commas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">left</td><td>The function expression to call (already parsed) </td></tr>
    <tr><td class="paramname">bp</td><td>The current binding power context (unused in this function)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created function call expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Function calls have very high precedence (BP_CALL) </dd>
<dd>
Arguments are stored in a growable array and can be of any expression type </dd>
<dd>
Empty argument lists are allowed: <span class="tt">function()</span> </dd>
<dd>
Arguments are separated by commas with optional trailing comma handling </dd>
<dd>
The function being called (left operand) can be any expression (identifier, member access, etc.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#ae0ffb62e012dd1c9f61cc84d939186dd">create_call_expr()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="structGrowableArray.html" title="Growable array backed by an arena allocator.">GrowableArray</a> </dd></dl>

</div>
</div>
<a id="a1ecf965f76c333d977e1ffafbef4174e" name="a1ecf965f76c333d977e1ffafbef4174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecf965f76c333d977e1ffafbef4174e">&#9670;&#160;</a></span>grouping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * grouping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses grouped expressions (parenthesized expressions) </p>
<p>Parses a grouped expression (parentheses).</p>
<p>This function handles expressions enclosed in parentheses, which are used to override the default operator precedence. The parentheses themselves don't create a separate AST node; they just influence parsing order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the expression AST node inside the parentheses, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Parentheses don't create additional AST nodes - they only affect parsing order </dd>
<dd>
The inner expression is parsed with BP_LOWEST to allow any expression inside </dd>
<dd>
Both opening and closing parentheses are consumed and required </dd>
<dd>
Nested parentheses are handled naturally through recursive expression parsing</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#aa7af0b51959be1abcc6af1869796e4a2">create_grouping_expr()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="parser_8h.html#a8ae2c122d273b1681a60ee873efe2a4f" title="Consume a token of the specified type, or report an error.">p_consume()</a> </dd></dl>

</div>
</div>
<a id="a6ec4a015146e7598655f260ecb559a84" name="a6ec4a015146e7598655f260ecb559a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec4a015146e7598655f260ecb559a84">&#9670;&#160;</a></span>prefix_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * prefix_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a></td>          <td class="paramname"><span class="paramname"><em>bp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses prefix expressions (member access, indexing, postfix operators) </p>
<p>Parses a prefix expression (member access, postfix operators, indexing).</p>
<p>This function handles expressions that operate on a left operand:</p><ul>
<li>Member access: <span class="tt">object.member</span></li>
<li>Array indexing: <span class="tt">array[index]</span></li>
<li>Postfix increment/decrement: <span class="tt">variable++</span>, <span class="tt">variable--</span></li>
</ul>
<p>Despite the name "prefix", this function handles postfix and infix operations that take a left operand. It's part of the led (left denotation) mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">left</td><td>The left operand expression (object, array, or variable) </td></tr>
    <tr><td class="paramname">bp</td><td>The current binding power context (unused in this function)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the appropriate expression AST node (member, index, or unary), or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Despite the name, this handles postfix and member access operations </dd>
<dd>
Member access requires an identifier after the dot </dd>
<dd>
Array indexing can use any expression as the index </dd>
<dd>
Postfix increment/decrement create unary expressions with special operators </dd>
<dd>
All operations have high precedence (BP_CALL level)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#ae91465355deb23d350db38bad7ccf8bf">create_index_expr()</a>, <a class="el" href="ast_8h.html#a9b43fac7667a29730620575fd4ecde03">create_member_expr()</a>, <a class="el" href="ast_8h.html#ae5611431d21a9c94961e338eac2a5543">create_unary_expr()</a> </dd></dl>

</div>
</div>
<a id="a481c538e520948ab138a8c5b0a8324c6" name="a481c538e520948ab138a8c5b0a8324c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481c538e520948ab138a8c5b0a8324c6">&#9670;&#160;</a></span>primary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * primary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses primary expressions (literals and identifiers) </p>
<p>Parses a primary expression (literal, identifier).</p>
<p>This function handles the most basic expressions that don't have any operators: integer literals, floating-point literals, string literals, character literals, boolean literals, and identifiers. It uses a lookup table to map token types to literal types and handles the appropriate conversion and memory allocation for each type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created literal or identifier expression AST node, or NULL if the current token is not a valid primary expression</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Primary expressions are the "atoms" of the expression language </dd>
<dd>
Memory for literal values is allocated using the arena allocator </dd>
<dd>
String literals are copied to ensure they remain valid after parsing </dd>
<dd>
Identifiers are handled separately and create identifier expression nodes </dd>
<dd>
Numeric conversions use standard library functions (strtoll, strtod) </dd>
<dd>
Boolean literals are converted from "true"/"false" string comparisons</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#a3fe1e61e4cbaa650ee0303706f5c730a">create_literal_expr()</a>, <a class="el" href="ast_8h.html#aa428edcfee9f652c053e31e0135acbd6">create_identifier_expr()</a>, <a class="el" href="parser_8h.html#a8779384c9ac7a618c2b851cb11d1598c" title="Retrieves the name string from the current token (for identifiers).">get_name()</a> </dd></dl>

</div>
</div>
<a id="a517fa2b63adec675d032991a3a712572" name="a517fa2b63adec675d032991a3a712572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517fa2b63adec675d032991a3a712572">&#9670;&#160;</a></span>unary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * unary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses unary expressions (prefix operators) </p>
<p>Parses a unary expression.</p>
<p>This function handles prefix unary operators such as negation (-), logical NOT (!), unary plus (+), and prefix increment/decrement (++, &ndash;). It uses a lookup table to map token types to unary operator types and recursively parses the operand with appropriate precedence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created unary expression AST node, or NULL if the current token is not a valid unary operator</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unary expressions have higher precedence than most binary operators </dd>
<dd>
The operand is parsed with BP_UNARY precedence to handle operator nesting </dd>
<dd>
Supports both arithmetic unary operators (-, +) and logical operators (!) </dd>
<dd>
Prefix increment/decrement operators are handled here (postfix in prefix_expr)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#ae5611431d21a9c94961e338eac2a5543">create_unary_expr()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="ast_8h.html#ac0e6f7f17047750fd114b6634912dca4">UnaryOp</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
