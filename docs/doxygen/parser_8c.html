<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lux: src/parser/parser.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lux<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A low-level compiled alternative to C, C++, and more!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="dir_6cd8491d143eb218b70983dbdb3c58bc.html">parser</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">parser.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of the parser module for the programming language compiler.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdalign.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ast_8h_source.html">../ast/ast.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="error_8h_source.html">../c_libs/error/error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memory_8h_source.html">../c_libs/memory/memory.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="parser_8h_source.html">parser.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for parser.c:</div>
<div class="dyncontent">
<div class="center"><img src="parser_8c__incl.png" border="0" usemap="#asrc_2parser_2parser_8c" loading="lazy" alt=""/></div>
<map name="asrc_2parser_2parser_8c" id="asrc_2parser_2parser_8c">
<area shape="rect" title="Implementation of the parser module for the programming language compiler." alt="" coords="147,5,280,30"/>
<area shape="rect" title=" " alt="" coords="5,296,83,321"/>
<area shape="poly" title=" " alt="" coords="148,32,104,50,85,63,69,80,55,103,45,129,35,185,36,238,41,280,36,281,31,238,30,184,39,128,50,101,65,76,81,59,102,45,146,27"/>
<area shape="rect" title=" " alt="" coords="79,78,140,103"/>
<area shape="poly" title=" " alt="" coords="198,33,140,71,138,67,195,28"/>
<area shape="rect" href="ast_8h.html" title=" " alt="" coords="150,151,234,175"/>
<area shape="poly" title=" " alt="" coords="214,31,205,78,198,136,192,135,200,78,208,30"/>
<area shape="rect" href="memory_8h.html" title="Arena allocator and growable array utilities for fast memory management." alt="" coords="231,223,412,248"/>
<area shape="poly" title=" " alt="" coords="241,28,271,48,298,77,313,110,322,145,326,207,320,208,316,146,308,111,294,79,268,52,238,33"/>
<area shape="rect" href="error_8h.html" title="Error reporting utilities for lexer and parser diagnostics." alt="" coords="400,78,538,103"/>
<area shape="poly" title=" " alt="" coords="256,28,413,71,412,76,255,33"/>
<area shape="rect" href="parser_8h.html" title="Recursive descent and Pratt parser for the Zura language." alt="" coords="215,78,284,103"/>
<area shape="poly" title=" " alt="" coords="222,29,239,63,234,66,217,32"/>
<area shape="rect" title=" " alt="" coords="284,296,358,321"/>
<area shape="poly" title=" " alt="" coords="196,175,203,210,210,229,221,246,246,270,276,287,273,291,243,274,217,250,205,231,198,211,190,176"/>
<area shape="rect" title=" " alt="" coords="109,296,176,321"/>
<area shape="poly" title=" " alt="" coords="191,176,154,282,149,280,186,175"/>
<area shape="poly" title=" " alt="" coords="215,174,288,213,286,218,212,178"/>
<area shape="poly" title=" " alt="" coords="276,251,98,296,97,291,275,246"/>
<area shape="poly" title=" " alt="" coords="324,249,324,280,319,280,319,249"/>
<area shape="poly" title=" " alt="" coords="293,251,187,292,185,287,291,246"/>
<area shape="poly" title=" " alt="" coords="482,102,497,123,510,150,527,201,527,225,514,250,485,277,449,295,410,305,374,309,374,304,409,300,447,290,482,273,510,246,522,223,522,202,506,152,493,126,478,105"/>
<area shape="poly" title=" " alt="" coords="479,102,493,137,494,158,488,177,460,203,426,221,424,216,457,199,483,174,489,157,488,138,474,104"/>
<area shape="rect" href="lexer_8h.html" title="Tokenizer (lexer) definitions and API for lexical analysis of source code." alt="" coords="359,151,473,175"/>
<area shape="poly" title=" " alt="" coords="463,105,436,140,432,137,458,102"/>
<area shape="poly" title=" " alt="" coords="402,178,350,216,347,212,399,174"/>
<area shape="rect" title=" " alt="" coords="436,223,500,248"/>
<area shape="poly" title=" " alt="" coords="427,174,453,209,448,212,422,177"/>
<area shape="poly" title=" " alt="" coords="242,105,213,140,209,137,238,102"/>
<area shape="poly" title=" " alt="" coords="215,102,174,121,156,134,141,152,129,184,126,219,130,252,137,280,131,282,125,253,121,219,124,183,136,149,152,131,171,116,213,98"/>
<area shape="poly" title=" " alt="" coords="257,102,311,208,306,211,253,104"/>
<area shape="poly" title=" " alt="" coords="278,101,375,142,373,147,276,106"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9a2a8ba5bea0c6ee41058bf6f8eb6178" id="r_a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a2a8ba5bea0c6ee41058bf6f8eb6178">parser_error</a> (<a class="el" href="structParser.html">Parser</a> *psr, const char *error_type, const char *file, const char *msg, int line, int col, int tk_length)</td></tr>
<tr class="memdesc:a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a parser error with detailed location information.  <br /></td></tr>
<tr class="memitem:a92a3429a7335866e6d3e6da546e7dbab" id="r_a92a3429a7335866e6d3e6da546e7dbab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92a3429a7335866e6d3e6da546e7dbab">parse</a> (<a class="el" href="structGrowableArray.html">GrowableArray</a> *tks, <a class="el" href="structArenaAllocator.html">ArenaAllocator</a> *arena)</td></tr>
<tr class="memdesc:a92a3429a7335866e6d3e6da546e7dbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main parsing function that converts tokens into an AST.  <br /></td></tr>
<tr class="memitem:abd32c60384ae40c357cc28e65fd764d1" id="r_abd32c60384ae40c357cc28e65fd764d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd32c60384ae40c357cc28e65fd764d1">get_bp</a> (<a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a> kind)</td></tr>
<tr class="memdesc:abd32c60384ae40c357cc28e65fd764d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the binding power (precedence) for a given token type.  <br /></td></tr>
<tr class="memitem:a39ffb04f9526d5ee88fa488db078cbc1" id="r_a39ffb04f9526d5ee88fa488db078cbc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ffb04f9526d5ee88fa488db078cbc1">nud</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a39ffb04f9526d5ee88fa488db078cbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null Denotation - handles prefix expressions and primary expressions.  <br /></td></tr>
<tr class="memitem:ad715ebb051a669c00dc55cdcd31bed2d" id="r_ad715ebb051a669c00dc55cdcd31bed2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad715ebb051a669c00dc55cdcd31bed2d">led</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:ad715ebb051a669c00dc55cdcd31bed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left Denotation - handles binary and postfix expressions.  <br /></td></tr>
<tr class="memitem:a2701baa126589d22ff03eb7ebbada5f5" id="r_a2701baa126589d22ff03eb7ebbada5f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2701baa126589d22ff03eb7ebbada5f5">parse_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:a2701baa126589d22ff03eb7ebbada5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an expression using the Pratt parsing algorithm.  <br /></td></tr>
<tr class="memitem:aad4d5835f66e6e7e08a1358b18152665" id="r_aad4d5835f66e6e7e08a1358b18152665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad4d5835f66e6e7e08a1358b18152665">parse_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:aad4d5835f66e6e7e08a1358b18152665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single statement.  <br /></td></tr>
<tr class="memitem:a16d4d98cf3fc80e10331bcd1d8b77e26" id="r_a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16d4d98cf3fc80e10331bcd1d8b77e26">parse_type</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a type annotation.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the parser module for the programming language compiler. </p>
<p>This file contains the core parsing functionality that converts a stream of tokens into an Abstract Syntax Tree (AST). The parser uses a Pratt parser approach for handling operator precedence and associativity in expressions.</p>
<p>The parser supports:</p><ul>
<li>Statement parsing (variables, functions, control flow, etc.)</li>
<li>Expression parsing with proper operator precedence</li>
<li><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> parsing for type annotations</li>
<li>Error reporting with source location information</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Connor Harris </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2025 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="abd32c60384ae40c357cc28e65fd764d1" name="abd32c60384ae40c357cc28e65fd764d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd32c60384ae40c357cc28e65fd764d1">&#9670;&#160;</a></span>get_bp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> get_bp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a></td>          <td class="paramname"><span class="paramname"><em>kind</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the binding power (precedence) for a given token type. </p>
<p>Gets the binding power (precedence) of a token type.</p>
<p>This function is crucial for the Pratt parser implementation. It returns the binding power (precedence level) for different operators, which determines the order of operations during expression parsing.</p>
<p>Higher binding power values indicate higher precedence operators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>The token type to get binding power for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a> enumeration value representing the precedence level Returns BP_NONE for tokens that don't have binding power</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Precedence levels (highest to lowest):<ul>
<li>BP_CALL: Function calls, member access, indexing</li>
<li>BP_POSTFIX: Postfix increment/decrement</li>
<li>BP_PRODUCT: Multiplication, division</li>
<li>BP_SUM: Addition, subtraction</li>
<li>BP_RELATIONAL: Comparison operators</li>
<li>BP_EQUALITY: Equality and inequality</li>
<li>BP_BITWISE_AND, BP_BITWISE_XOR, BP_BITWISE_OR: Bitwise operations</li>
<li>BP_LOGICAL_AND, BP_LOGICAL_OR: Logical operations</li>
<li>BP_TERNARY: Ternary conditional operator</li>
<li>BP_ASSIGN: Assignment operators</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921" title="Enumeration of all possible token types recognized by the lexer.">TokenType</a> </dd></dl>

</div>
</div>
<a id="ad715ebb051a669c00dc55cdcd31bed2d" name="ad715ebb051a669c00dc55cdcd31bed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad715ebb051a669c00dc55cdcd31bed2d">&#9670;&#160;</a></span>led()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * led </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *</td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a></td>          <td class="paramname"><span class="paramname"><em>bp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left Denotation - handles binary and postfix expressions. </p>
<p>Pratt parser function for left denotation (infix/postfix parsing).</p>
<p>This is part of the Pratt parser implementation. The "led" function handles tokens that can appear after an expression has been parsed (binary operators and postfix operators).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">left</td><td>The left operand expression (already parsed) </td></tr>
    <tr><td class="paramname">bp</td><td>The current binding power context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node incorporating the left operand, or the original left expression if no valid LED is found</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Binary arithmetic and logical operators: +, -, *, /, ==, !=, etc.</li>
<li>Function calls: function(args)</li>
<li>Assignment: variable = value</li>
<li>Member access: object.member</li>
<li>Postfix operators: variable++, variable&ndash;</li>
<li>Array indexing: array[index]</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Pratt parser function for null denotation (prefix parsing).">nud()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="parser_8h.html#aae76f2e2da0e519b78628915240200dd" title="Parses a binary expression.">binary()</a>, <a class="el" href="parser_8h.html#a77a8786dfb25898d7c4ffbc0ca8eafcf" title="Parses a function call expression.">call_expr()</a>, <a class="el" href="parser_8h.html#a683f4d2d2d297649d7b0d2d3dc3bad8e" title="Parses an assignment expression.">assign_expr()</a>, <a class="el" href="parser_8h.html#a6ec4a015146e7598655f260ecb559a84" title="Parses a prefix expression (member access, postfix operators, indexing).">prefix_expr()</a> </dd></dl>

</div>
</div>
<a id="a39ffb04f9526d5ee88fa488db078cbc1" name="a39ffb04f9526d5ee88fa488db078cbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ffb04f9526d5ee88fa488db078cbc1">&#9670;&#160;</a></span>nud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * nud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null Denotation - handles prefix expressions and primary expressions. </p>
<p>Pratt parser function for null denotation (prefix parsing).</p>
<p>This is part of the Pratt parser implementation. The "nud" function handles tokens that can appear at the beginning of an expression (prefix operators and primary expressions like literals and identifiers).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Primary expressions: numbers, strings, identifiers</li>
<li>Prefix unary operators: -, +, !, ++, &ndash;</li>
<li>Grouped expressions: (expression)</li>
<li>Array literals: [expression, ...]</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Pratt parser function for left denotation (infix/postfix parsing).">led()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression with a given minimum binding power.">parse_expr()</a>, <a class="el" href="parser_8h.html#a481c538e520948ab138a8c5b0a8324c6" title="Parses a primary expression (literal, identifier).">primary()</a>, <a class="el" href="parser_8h.html#a517fa2b63adec675d032991a3a712572" title="Parses a unary expression.">unary()</a>, <a class="el" href="parser_8h.html#a1ecf965f76c333d977e1ffafbef4174e" title="Parses a grouped expression (parentheses).">grouping()</a>, <a class="el" href="parser_8h.html#ade768344c2d92f84219dfbddb9d37987" title="Parses an array literal expression.">array_expr()</a> </dd></dl>

</div>
</div>
<a id="a92a3429a7335866e6d3e6da546e7dbab" name="a92a3429a7335866e6d3e6da546e7dbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a3429a7335866e6d3e6da546e7dbab">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGrowableArray.html">GrowableArray</a> *</td>          <td class="paramname"><span class="paramname"><em>tks</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structArenaAllocator.html">ArenaAllocator</a> *</td>          <td class="paramname"><span class="paramname"><em>arena</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main parsing function that converts tokens into an AST. </p>
<p>Parses a full program from tokens into an AST of statements.</p>
<p>This is the entry point for the parser. It takes a growable array of tokens and converts them into a complete program AST node containing all parsed statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tks</td><td>Growable array containing all tokens from the lexer </td></tr>
    <tr><td class="paramname">arena</td><td>Arena allocator for memory management during parsing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root AST node (Program node) containing all parsed statements, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function estimates the initial capacity for statements based on token count </dd>
<dd>
All memory allocations use the provided arena allocator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParser.html" title="Parser state holding token stream and current position.">Parser</a>, <a class="el" href="parser_8h.html#aad4d5835f66e6e7e08a1358b18152665" title="Parses a single statement.">parse_stmt()</a>, <a class="el" href="ast_8h.html#a60c38b33bb0195508a6cd65fb541e226">create_program_node()</a> </dd></dl>

</div>
</div>
<a id="a2701baa126589d22ff03eb7ebbada5f5" name="a2701baa126589d22ff03eb7ebbada5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2701baa126589d22ff03eb7ebbada5f5">&#9670;&#160;</a></span>parse_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * parse_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a></td>          <td class="paramname"><span class="paramname"><em>bp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an expression using the Pratt parsing algorithm. </p>
<p>Parses an expression with a given minimum binding power.</p>
<p>This is the core expression parsing function that implements the Pratt parser algorithm. It handles operator precedence and associativity automatically through the binding power mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">bp</td><td>Minimum binding power - only operators with higher binding power will be consumed by this call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm works by:<ol type="1">
<li>Getting the left expression using <a class="el" href="parser_8h.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Pratt parser function for null denotation (prefix parsing).">nud()</a></li>
<li>While the next operator has higher binding power than bp:<ul>
<li>Use <a class="el" href="parser_8h.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Pratt parser function for left denotation (infix/postfix parsing).">led()</a> to extend the expression with the operator</li>
</ul>
</li>
<li>Return the final expression</li>
</ol>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Pratt parser function for null denotation (prefix parsing).">nud()</a>, <a class="el" href="parser_8h.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Pratt parser function for left denotation (infix/postfix parsing).">led()</a>, <a class="el" href="parser_8h.html#abd32c60384ae40c357cc28e65fd764d1" title="Gets the binding power (precedence) of a token type.">get_bp()</a>, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a> </dd></dl>

</div>
</div>
<a id="aad4d5835f66e6e7e08a1358b18152665" name="aad4d5835f66e6e7e08a1358b18152665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4d5835f66e6e7e08a1358b18152665">&#9670;&#160;</a></span>parse_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * parse_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a single statement. </p>
<p>This function dispatches to the appropriate statement parsing function based on the current token. It also handles visibility modifiers (public/private) that can appear before certain statement types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed statement AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Variable declarations: const, var</li>
<li>Control flow: return, if, loop, break, continue</li>
<li>Block statements: { ... }</li>
<li>Print statements: print, println</li>
<li>Expression statements: any expression followed by semicolon</li>
<li>Visibility modifiers: public, private (applied to declarations)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#acd0470a765c07f4aa6855db5449e351a" title="Parses a constant declaration statement.">const_stmt()</a>, <a class="el" href="parser_8h.html#a74b60c0d077f19dca00679311b5ce1d9" title="Parses a variable declaration statement.">var_stmt()</a>, <a class="el" href="parser_8h.html#a65feab14f178a93af29954494842495c" title="Parses a return statement.">return_stmt()</a>, <a class="el" href="parser_8h.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="parser_8h.html#a5a2c054597dd672f140bd9859e51da10" title="Parses an if statement.">if_stmt()</a>, <a class="el" href="parser_8h.html#a116eace6cdf11c0f5a066af2e7c069b1" title="Parses a loop statement.">loop_stmt()</a>, <a class="el" href="parser_8h.html#a5dc127de3e1e39ab9270bd87fe3733a6" title="Parses a print statement.">print_stmt()</a>, <a class="el" href="parser_8h.html#ab63fdeaaa163c06ed9af09d86379b060" title="Parses a break or continue statement.">break_continue_stmt()</a>, <a class="el" href="parser_8h.html#a25a630a2b0ae343cd5bd2016c545a2ac" title="Parses an expression statement.">expr_stmt()</a> </dd></dl>

</div>
</div>
<a id="a16d4d98cf3fc80e10331bcd1d8b77e26" name="a16d4d98cf3fc80e10331bcd1d8b77e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d4d98cf3fc80e10331bcd1d8b77e26">&#9670;&#160;</a></span>parse_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> * parse_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>parser</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a type annotation. </p>
<p>Parses a type expression.</p>
<p>This function parses type expressions used in variable declarations, function parameters, return types, etc. It handles primitive types, pointer types, array types, and user-defined types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed <a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Primitive types: int, uint, float, bool, string, void, char</li>
<li>Pointer types: *type</li>
<li>Array types: [size]type or []type</li>
<li>User-defined types: identified by TOK_IDENTIFIER</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prints error message to stderr for unexpected tokens</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a4b598fef0adda01f89712c89e337c315" title="Type parsing null denotation function.">tnud()</a>, <a class="el" href="parser_8h.html#ac9cffb5ed1ef3cd27b0dbcd511044919" title="Type parsing left denotation function.">tled()</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921" title="Enumeration of all possible token types recognized by the lexer.">TokenType</a> </dd></dl>

</div>
</div>
<a id="a9a2a8ba5bea0c6ee41058bf6f8eb6178" name="a9a2a8ba5bea0c6ee41058bf6f8eb6178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2a8ba5bea0c6ee41058bf6f8eb6178">&#9670;&#160;</a></span>parser_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *</td>          <td class="paramname"><span class="paramname"><em>psr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>error_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tk_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a parser error with detailed location information. </p>
<p>Report a parser error with detailed location info.</p>
<p>Creates and adds an error to the global error system with information about where the error occurred in the source code, including line and column information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">error_type</td><td>String describing the type of error (e.g., "SyntaxError") </td></tr>
    <tr><td class="paramname">file</td><td>Path to the source file where the error occurred </td></tr>
    <tr><td class="paramname">msg</td><td>Detailed error message describing what went wrong </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the error occurred (1-based) </td></tr>
    <tr><td class="paramname">col</td><td>Column number where the error occurred (1-based) </td></tr>
    <tr><td class="paramname">tk_length</td><td>Length of the token that caused the error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function uses the arena allocator to duplicate the line text </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structErrorInformation.html" title="Stores detailed information about an error.">ErrorInformation</a>, <a class="el" href="error_8c.html#a4f3d659181bf27a69270daa8d5ab0658" title="Adds an error to the internal error list.">error_add()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
